I"3<p><br /></p>

<h1 id="0x00-介绍">0x00 介绍</h1>
<hr />

<p>针对大型企业系统的攻击在全球范围内呈上升趋势，端点监控系统将这些复杂的攻击活动记录为审计日志，接着安全分析师对审计日志进行因果分析并确定攻击过程。但是正常系统产生的审计日志数量却非常多，最新的研究方向主要是通过消除审计日志中的无关操作来提高因果分析能力，另一个方向是提高日志查询系统的效率，但这些改进都不会使工作消耗大幅减少，所以分析师面临的主要问题还是低级审计事件和高级系统行为之间的语义差距。虽然行为抽象听起来很有前途，但提取行为并推断语义主要面临两个主要挑战：事件语义区分和行为识别。由于大规模审计事件高度交错，划分事件和识别行为边界就像大海捞针。<br />
为了解决上述问题，作者设计了 WATSON，该系统通过聚合审计事件的语义来建立行为模式，利用基于翻译的嵌入模型，根据审计日志的上下文信息推断审计事件的语义，然后再聚合语义来作为高级行为的表示并区分出安全分析师需要的行为。作者在企业环境中模拟了 17 个正常程序和 8 个现实生活的攻击，并且对 WATSON 的正确性和可解释性进行了评估。</p>

<h1 id="0x01-贡献">0x01 贡献</h1>
<hr />

<ol>
  <li>本文设计的 WATSON 是第一种从低级日志中抽象高级行为的系统，通过使用信息流作为指导总结行为，并通过聚合审计事件的上下文语义来派生行为语义。</li>
  <li>提出了通过上下文信息推断日志语义的新思想，提供行为语义的定量表示，并将其用来聚类相似的行为和提取代表性的行为。</li>
  <li>对常见的良性行为和现实中的恶意行为进行系统评估，结果表明 WATSON 能够有效地抽取高层次行为，减少日志分析中的工作量。</li>
</ol>

<h1 id="0x02-背景">0x02 背景</h1>
<hr />

<h3 id="1-现实攻击">1. 现实攻击：</h3>

<p>当窃取机密内容时，为了扰乱分析人员的视线，窃密者会先将 secret.txt 用 gcc 进行编译后再使用 git 上传。研究人员为了便于攻击因果分析，普遍采用溯源图来有效跟踪审计日志中的信息流，如下图所示，分析人员会先从警告事件执行时间轴向前的跟踪（backward tracking）找到攻击的根源，然后分析人员对发现的初始漏洞再执行时间轴向后的跟踪（forward tracking）研究攻击产生的一系列后果。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-08-01.png" alt="攻击溯源图" /></p>

<h3 id="2-挑战">2. 挑战：</h3>

<p>在捕获攻击序列和来源时，研究人员不仅需要识别恶意行为（如数据泄露），还需要识别并排除良性行为（如程序编译和上传），尽管溯源图提供了可视化的因果关系，但并没有删除其中不相关的事件。由于审计日志数量过于庞大，分析人员需要花费过多的时间来调查无关事件。从审计日志中提取行为是分析专家在分析过程中的有效策略，这个过程想要自动化面临两个挑战：</p>

<ol>
  <li>系统级别审计事件的推断：现有工作主要使用专家定义的规则或模型的知识库来解析审计事件，由于审计事件的规模较大，手动定义规范很容易破环行为抽象的可扩展性。</li>
  <li>识别大规模审计事件的行为边界：所有单个行为之间都有因果关系，这使得分析人员很难划分事件范围并区分行为边界。</li>
</ol>

<h3 id="3-威胁建模">3. 威胁建模</h3>

<p>假设底层系统、审计引擎和监控数据都是可信计算基（Trust Computing Base，TCB）的一部分，作者的工作都基于这些内核层的审计，并且只关注单个用户会话的行为，同时也适用于跨会话或跨机器间的行为。</p>

<h1 id="0x03-总体框架">0x03 总体框架</h1>
<hr />

<p>作者设计的 WATSON 包括三个主要阶段：知识图谱的构建、行为抽象和代表性行为的识别，如下图所示，WATSON 以系统审计数据作为输入，总结行为实例并揭示语义，最后输出有具有代表性的高级行为。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-08-02.png" alt="总体框架" /></p>

<ol>
  <li><strong>知识图谱构建（Knowledge Graph Construction）：</strong> 为了分析事件的上下文语义，需要以同构的方式表示异构事件，作者提出了新的基于知识图谱（KG）的表示方法来集成异构信息。基于审计日志的知识图谱是众多语义三元组的集合，其中每个三元组对应一个审计事件，以（Head，Relation，Tail）的形式对头和尾之间的语义关系进行编码。</li>
  <li><strong>事件语义推理（Event Semantics Inference）：</strong> 单个审计事件包括三个元素，其中每个元素分别贡献对事件的语义，所以与事件级别相比，在元素级别上执行语义分析可以提供一个更详细的视图。接着使用基于翻译的嵌入模型（TransE）将元素映射到向量空间中学习其语义。最终 TransE 的输出结果是一个 n * m 的嵌入矩阵，将 n 维的一次性编码元素映射到 m 维的嵌入空间，为了进一步推断审计事件语义，将组成元素的嵌入连接起来生成 3m 维的向量。</li>
  <li><strong>行为总结（Behavior Summarization）：</strong> 行为抽象的下一步是从单个用户的会话中识别行为实例，作者将行为实例定义为对相关数据操作并由信息流关联的一系列审计事件，所以总结个体行为实例的问题简化为在会话的 KG 中提取以数据对象（文件和网络套接字）为根的因果连接子图。作者应用了一种自适应的 DFS 算法将会话的 KG 划分为子图，每个子图描述一个行为实例，如下图所示。
<img src="https://bu-shuo.github.io/image/2021-08-08-03.png" alt="子图划分" /></li>
  <li><strong>行为语义聚合（Behavior Semantics Aggregation）：</strong> 行为无关的事件在会话中更普遍，因为它们在不同的行为中重复出现，而实际相关的事件发生频率较低，所以使用逆文档频率（IDF）来自动赋予每个操作的相对重要性，同时减少由审计日志的低级和冗长性质带来的噪声事件有助于提高 WATSON 的效率。</li>
  <li><strong>行为聚类（Behavior Clustering）：</strong> 行为签名是簇中最具代表性的实例，分析人员只需要研究几个自动选择的签名进行行为匹配，而不是研究整个簇空间。通过给定行为实例的向量，WATSON 使用聚类层次分析（Hierarchical Clustering Analysis，HCA）算法对相似行为进行聚类。一旦标识了簇，根据有代表性的行为实例提取每个集群的行为签名，通过区分行为签名，可以减少大量的分析工作。</li>
</ol>

<h1 id="0x04-实验评估">0x04 实验评估</h1>
<hr />

<p><img src="https://bushuo.github.io/image/2021-08-01-05.png" alt="去混淆流程" /></p>

<ol>
  <li><strong>可疑子树的提取（Extract Suspicious Subtrees）：</strong> 采用了微软的官方库 System.Management.Automation.Language 将 PowerShell 脚本解析为 AST ，因为只有两种方法可以将恢复的部分直接通过管道（pipes）或间接通过变量传递给上面的顶点。如下图所示，一种为红色块所指的 PipelineAst 节点，另一种为蓝色块所指的 AssignmentStatementAst 节点。并以宽度优先的方式遍历 AST，并将可疑的子树推入堆栈中进行后续步骤。
<img src="https://bushuo.github.io/image/2021-08-01-06.png" alt="两种节点" /></li>
  <li><strong>基于子树的混淆检测（Subtree-based Obfuscation Detection）：</strong> 部署二进制分类器通过脚本片段熵、标记（token）的长度、AST 类型的分布和 AST 的深度四种特征去发现混淆的子树或脚本片段（并不是所有满足模糊特征的树都是可恢复的子树），最终选取了 76 种特征并使用基于梯度下降的 Logistics 回归算法进行分类。</li>
  <li><strong>基于仿真的恢复（Emulation-based Recovery）：</strong> 设置一个 PowerShell 执行会话，并执行在上一步中检测到的混淆部分，若为可恢复子树，则返回恢复后的脚本；若为不可恢复子树，则将其标记为非模糊子树，继续下一个模糊子树。</li>
  <li><strong>抽象语法树的更新（AST Update）：</strong> 将恢复的子树或脚本片段解析为新的 AST 并替换更新 AST，循环这样的过程直到没有混淆的子树。</li>
  <li><strong>后处理阶段（Post processing）：</strong> 对混淆过程中引入的语法及更改通过正则表达式进行定位，并进行相应的修改，重新构建脚本片段以获得消除混淆后的脚本。</li>
</ol>

<h1 id="0x05-语义感知的-powershell-攻击检测系统">0x05 语义感知的 PowerShell 攻击检测系统</h1>
<hr />

<p>基于语义感知的系统除了可以提供稳定的攻击检测，还允许对恶意行为进行解释和分类。由于 PowerShell 脚本的 API 包含更高级别的语义，因此 PowerShell 脚本的语义可以更容易地通过命令和函数集来理解，所以该系统采用 API 集来进行语义检测。</p>

<h3 id="1-训练阶段training-phase">1. 训练阶段（Training Phase）</h3>
<p>使用解析器解析得到一组对应于每个去混淆脚本的 AST 节点，然后提取它们的值并对其进行规范化：转换为小写字母，再删除无关字符，最后检查别名。采用基于 OOA 挖掘的经典分类方法对命令项集合进行检测，如下图所示，字母表示命令或函数，用红色标记的集合表示从恶意脚本中提取的项目集，再使用 FP-growth 算法生成频度模式，然后选择满足支持度和置信度大于用户指定的最小值规则的模式。最终，作者为 PowerShell 攻击提取了 31 条确定的 OOA 规则。</p>

<p><img src="https://bushuo.github.io/image/2021-08-01-07.png" alt="提取项目集" /></p>

<h3 id="2-检测阶段detection-phase">2. 检测阶段（Detection Phase）</h3>
<p>使用去混淆的脚本作为项目集，并尝试匹配预先训练的 OOA 规则，结果不仅显示了恶意分数，还显示了脚本的语义。</p>

<h1 id="0x06-实验评估">0x06 实验评估</h1>
<hr />

<h3 id="1-混淆检测的准确性">1. 混淆检测的准确性</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-08.png" alt="混淆检测的准确性" /></p>

<h3 id="2-脚本恢复的质量">2. 脚本恢复的质量</h3>

<p><img src="https://bushuo.github.io/image/2021-08-01-09.png" alt="脚本恢复的质量" /></p>

<h3 id="3-去混淆的效率">3. 去混淆的效率</h3>

<p><img src="https://bushuo.github.io/image/2021-08-01-10.png" alt="去混淆的效率" /></p>

<h3 id="4-去混淆对-av-检测和语义感知检测结果的影响">4. 去混淆对 AV 检测和语义感知检测结果的影响</h3>

<p><img src="https://bushuo.github.io/image/2021-08-01-11.png" alt="去混淆对 AV 检测和语义感知检测结果的影响" /></p>
<h3 id="5-去混淆方法中单个技术的影响">5. 去混淆方法中单个技术的影响</h3>

<p><img src="https://bushuo.github.io/image/2021-08-01-12.png" alt="去混淆方法中单个技术的影响" /></p>

<h1 id="0x07-现有工作">0x07 现有工作</h1>
<hr />

<h3 id="1-基于脚本的恶意软件检测">1. 基于脚本的恶意软件检测</h3>
<p>如下图所示，对于脚本的恶意软件检测可以分为三类：</p>

<p><img src="https://bushuo.github.io/image/2021-08-01-13.png" alt="恶意软件检测分类" /></p>

<h3 id="2-去混淆方法">2. 去混淆方法</h3>
<p>对于二进制文件的混淆，精确识别混淆是去混淆的第一步，使用基于签名的方法可以在可执行文件种搜索已知的混淆。为了处理未知的混淆方式，最新的研究采用了多特征混淆检测。而对于脚本语言来说，Liu 等人提出了 PSDEM，这是一种主要用于 PowerShell 去混淆的手动方法。Adbelkhalek 提出的 JSDES 是一种混合的方法，用于识别混淆处理的可疑函数，然后对这些函数去混淆。Lu 等人提出的基于语义的方法使用了动态分析和程序切片技术来去混淆，但这种方法的问题是代码覆盖率低。</p>

<h1 id="0x08-总结">0x08 总结</h1>
<hr />

<p>这篇论文作者首先设计了第一种有效且轻量级的去混淆方法，该方法在子树级别上执行混淆检测和基于方针的恢复，在此基础上作者又进一步设计了第一个基于语义感知的 PowerShell 攻击检测系统，该系统包括 31 个 OOA 规则。通过实验，在使用作者设计的去混淆方法后，Windows Defender 和 Virus Total 的攻击检测率从 0.3% 和 2.65% 大幅提高到 75.0% 和 90.0%，而语义感知攻击检测系统的平局准确率为 92.3%，误报率为 0%，要优于 Windows Defender 和 VirusTotal。</p>
:ET