I"'<p><br /></p>

<h1 id="0x00-简介">0x00 简介</h1>
<hr />

<p>一个攻击者主要的目标就是完成特定任务并且不被发现，这个过程包括了在目标环境中建立一个立足点并进行横向移动，在真实攻击过程中，攻击者是在对目标安全控制系统所知甚少的情况下进行的。因此，攻击者必须注意调整他们的战略来保证不被安全控制系统所发现。随着新技术的不断发展，安全控制技术也逐渐成熟，这促使各种类型的攻击者调整和改进他们的策略，以此来最大限度提高攻击成功的可能性。</p>

<p>从攻击者的角度来看，最具挑战的新技术就是端点检测响应系统（Endpoint Detection and Response，EDR），它总是被称为未来的杀毒软件（Antivirus，AV）。传统的 AV 主要通过结合签名和启发式分析技术来加强对恶意代码的检测和防御，然而，EDR 主要有两个任务： <strong>对恶意行为和其他签名的检测</strong> 和 <strong>便捷的分析和应急响应</strong> ，因为这些原因，EDR 已经成为全面防御攻击者的要求。</p>

<p>EDR 被设计用来检测发生在端点上的可疑行为，这些行为可能包括一个攻击范围，例如进程执行或进程注入，以及在内存中加载映像。一旦这些行为被识别，EDR 就该发挥第二个作用——作为防御者和应急响应的工具对检测到的行为进行响应。响应的过程包括将受害主机从网络中隔离，快速收集端点日志，重塑事件发生的时间线，收集和记录威胁指标，甚至会终止可以进程。</p>

<p>攻击者则是通过开发新的更复杂的技术去躲避在磁盘和内存上的检测来作为回应。这些技术不局限于传统的初始攻击向量，它们经常利用后渗透技术去躲避检测，实施这些技术的关键是能够 hook 到主机上的所有进程，因为 EDR 技术会在几毫秒内作出许多决定。</p>

<p>如果没有之前的优秀工作，这个项目是不可能实现的。许多人公开了 EDR 和 内存 Hook 方面的创新研究，这些工作的重点是绕过特定的产品。本文的目的则是更深入地探讨该主题，不是专注于仅用于特定产品的技术，而是识别多有 EDR 产品的系统性问题，以及攻击者如何无需事先了解客户的安全栈就可以利用它们绕过 EDR 产品，这需要涉及到先前讨论过的概念。</p>

<h1 id="0x01-什么是-hooking-">0x01 什么是 hooking ？</h1>
<hr />

<p>Hooking 是一项改变程序行为的技术，它允许 EDR 去监控进程的执行流程，收集这些信息用于行为分析和检测可疑或恶意的活动。这使得 EDR 可以更准确地检测初始攻击技术（如代码执行）和后渗透技术（如权限提升、横向移动或勒索软件活动）。</p>

<p>这些 hooks 将数据发送到端点上运行的 EDR 代理，以便实时处理监控的数据。EDR 通常安装在内核级别，需要最高特权访问，这么做的原因主要有两个：第一是避免被攻击者关闭或删除，因为访问内核运行的服务并不容易，想要实施攻击通常需要某种漏洞，或者攻击者已经在端点上取得高级特权。不过由于攻击者通常是“黑盒”攻击，所以假设最初的攻击还没有特权，必须通过后渗透阶段获得，如果不小心执行一些程序，可能就会被 EDR 捕获。第二就是因为在内核中运行可以提供 EDR 访问、控制和监视整个系统。</p>

<p>figure 1</p>

<p>代理经常通过加载他们的 DLL 将 hooks 放入进程中，DLL 会重新映射已经加载过的函数。这使得代理可以监控每个进程，收集监控的数据，通过不断地接受进程、磁盘和网络通信中的变化，代理将数据传递到产品的基于云的平台，在云平台上，所有的数据都将被处理，并且归类为恶意或者良性行为。虽然大部分预防控制是由代理执行，但通过对攻击技术的修改可以绕过代理的初始检测，这就是 EDR 平台在基于大范围收集的数据来识别恶意行为方面真正发挥作用的地方。</p>

<p>figure 2</p>

<p>例如，一个进程产生一个挂起的新进程，并修改新进程的内存权限去执行 WriteProcessMemory 过程，写入的数据是经过加密的，所以不会触发代理的任何恶意指标。然而，发送到 EDR 平台的监控数据仍然可以查看，并且将这些事件识别为 Process Hollowing 技术。所有的过程都在不到一秒的时间发生，为了确保威胁不会成功，这意味着代理需要带两的数据来作出分析决策。</p>

<p>为了进一步了解数据流如何工作，我们需要对 Windows 架构有所了解。首先，Windows 系统提供了大量的函数和 API 调用，应用程序可以利用它们执行代码。Windows API 的主要作用是在调用系统调用执行底层指令前对齐所有堆栈寄存器。</p>

<p>像 NTAllocateVitualMemory 等系统调用提供了一个低级接口，允许进程和操作系统交互。这些接口是过渡到内核的底层汇编指令，用于告诉 CPU 执行诸如分配内存、创建文件或将存储在特定缓冲区的数据写入磁盘等操作。这些系统调用驻留在 ntdll.dll 动态链接库（DLL）中，其中有许多没有记录，因为他们只执行底层汇编指令，系统调用不能被直接调用。</p>

<p>figure 3</p>

<p>当一个进程被执行时，系统 DLL 被加载，此时 EDR 代理 hook 特定的 API 函数和系统调用，如 VirtualAlloc 和 NTAllocateVirtualMemory。需要注意的是，每个 EDR 平台 hook 不同的函数和系统调用，提供不同的监控，进而产生不同的信息和不同的检测结果。随着执行流程的进行，EDR 的 hook 被触发，强制执行从系统 DLL 跳转到 EDR DLL，此时 EDR 执行一系列指令，然后返回系统 DLL。</p>

<p>figure 4</p>

<p>如下图所示，同一个系统调用被调用两次，这是由于用户模式和内核模式之间的转换。系统调用可能以字符 NT 或 ZW 为前缀，NT 系统调用表示来自用户模式的调用， ZW 系统调用表示来自内核模式的系统调用。无论前缀如何，底层的系统调用指令都是相同的。</p>

<p>figure 5</p>

<h1 id="0x02-为什么-edrs-要-hook-用户模式">0x02 为什么 EDRs 要 hook 用户模式</h1>
<hr />

<p>尽管内和模式是最高级别的访问类型，但它存在使 EDR 有效性变复杂的缺点。在内核模式下，可见性可能非常有限，因为有些数据只能在用户模式下可用，另外，第三方的内核驱动程序很难开发，如果没有经过适当的审查，系统不稳定的可能性会很大。内核通常被认为是系统中最脆弱的部分，内核态代码的任何错误都可能导致巨大的问题，甚至使系统完全崩溃。</p>

<p>对于攻击者来说，用户模式更有吸引力，因为它无法直接访问底层硬件，在用户模式下运行的代码必须使用与硬件交互的 API 函数，从而提高稳定性并减少系统范围的崩溃（因为程序崩溃不会影响系统运行）。因此，在用户模式下运行的应用程序需要最少的权限和更加稳定的运行，可以说，很多 EDR 严重以来用户态的 hook，而不是内核态的。</p>

<p>由于 hook 存在于用户模式并 hook 到我们的进程中，因此我们也可以控制它们。由于应用程序在用户态的上下文中运行，这意味着加载到进程中的所有内容都可以由用户以某种形式进行操作，需要注意的是，内存的一些敏感区域被设置为 Execute，Read（ER-）可以防止对这些区域进行修改，我们将在下面讨论一些技术解决这个问题。</p>

<h1 id="0x03-在内存中绕过-edrs">0x03 在内存中绕过 EDRs</h1>
<hr />

<p>在我们找到内存 hook 之前，我们需要识别 EDR 的 DLL，这是缩小搜索范围的冠军爱你，因为一个简单的应用程序也可以加载许多不同的 DLL，并且它们可以根据进程需要的功能进行更改，例如，任何 Windows 的套接字连接都需要 ws2_32.dll。</p>

<p>识别 EDR 的 DLL 就像查看 DLL 的名称或描述一样简单，其他技术可能涉及查找 DLL 的路径或查看 DLL 的代码签名正虚。有几个不错的工具可以做到这一点，在我们的例子中使用了 ProcessHacker2 —— 一个免费的进程监控软件，如下图所示，chrome 加载了多个 DLL，但其中一个在名称和描述上都很突出，因为名称包含了 EDR 产品的名称，而描述则写明了其用途。</p>

<p>figure 6</p>

<p>现在我们已经确定了 EDR 的 DLL，下一步就是搜索这些 hooks，为此我们需要更深入地了解这些系统级函数以及它们如何在堆栈上运行。如果我们使用开源调试器 x64dbg 看一下，我们可以看到每个 DLL 都有一系列导出函数，这些都是应用程序可利用的功能。</p>

<p>figure 7</p>

<p>我们指导系统调用是应用程序访问内核执行低级指令的唯一途径，让我们在汇编层面来看看这些指令如何执行。在 x64 体系结构中，每个系统调用都应以当前存储在 RCX 中的值移入 R10 开始，然后是向 EAX 寄存器移入十六进制值。这个十六进制值是一个系统服务号，对于每个系统调用都是唯一的，内核不知道实际执行的是什么指令，只是查找唯一的系统调用 ID 来确定要执行的指令。在此例中，您可以看到典型的系统调用的汇编形式。SYSCALL_ID 对于不同的系统调用是唯一的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov r10, rcx
mov eax, (SYSCALL_ID)
test byte ptr ds:[7FFE0308], 1
jne ntdll (ADDRESS)
syscall
ret
int 2E
ret
</code></pre></div></div>

:ET