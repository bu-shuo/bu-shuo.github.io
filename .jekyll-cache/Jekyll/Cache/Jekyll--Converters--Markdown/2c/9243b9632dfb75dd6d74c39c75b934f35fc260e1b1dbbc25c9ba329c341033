I"0<p><br /></p>

<h1 id="0x00-介绍">0x00 介绍</h1>
<hr />

<p>PowerShell 是一种具有面向对象的动态类型脚本语言，因为它预先安装在大多数 Windows 计算机上，可以直接访问特权系统功能，还可以直接从内存执行，所以 PowerShell 也在越来越多的网络攻击中使用。其中如何实现对脚本语言去混淆仍是一个未解决的研究问题，下图展示了目前具有代表性的脚本去混淆方法，以及在混淆检测精度、恢复质量和开销方面的比较。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-01.png" alt="具有代表性的去混淆方法比较" /></p>

<p>虽然本文的目标是 PowerShell，但去混淆方法也适用于如 JavaScript 等其他脚本。对于一个被混淆的脚本，在执行前会先将混淆的脚本片段恢复到原始脚本片段，所以本文的一个重点也就是如何精确地识别这些可恢复的脚本片段。在解决了混淆问题后，便可以设计基于语义的 PowerShell 攻击检测系统。</p>

<h1 id="0x01-贡献">0x01 贡献</h1>
<hr />

<ol>
  <li>为 PowerShell 脚本设计了第一种有效且轻量级的基于子树的去混淆方法，该方法在 PowerShell 脚本抽象语法树（AST）的子树上执行混淆检测和基于仿真的恢复。</li>
  <li>基于新的去混淆方法，设计了第一个语义感知的 PowerShell 攻击检测系统，该系统采用面向关联（OOA）挖掘算法获取 PowerShell 攻击特征。</li>
  <li>通过去混淆方法可以将混淆脚本与原始脚本的相似度从 0.5% 提高到 80% 左右，在使用去混淆方法后，语义感知攻击检测系统的平均准确率为 92.3% ，误报率为 0% ，同等情况下要优于 Windows Defender 和 Virus Total。</li>
</ol>

<h1 id="0x02-背景">0x02 背景</h1>
<hr />

<h3 id="1-通过-powershell-发起的-lotl-攻击和无文件攻击">1. 通过 PowerShell 发起的 LotL 攻击和无文件攻击</h3>

<ul>
  <li><strong>LotL 攻击:</strong> 指在攻击过程中尽可能减少文件的产生，只使用纯净的系统工具来躲避检测。</li>
  <li><strong>无文件攻击：</strong> 指避免在磁盘上留下任何痕迹的攻击。</li>
</ul>

<p>使用 PowerShell 发起攻击的原因：</p>
<ol>
  <li>从 Windows 7 和 Windows Server 2008 R2 开始，所有 Windows 电脑都预装了 PowerShell。</li>
  <li>作为一个强大的第三方管理工具，PowerShell 提供了对所有主要 Windows 组件的访问。</li>
  <li>PowerShell 脚本可以直接从内存中执行，不需要任何形式的隔离，因此可以避免在磁盘上留下恶意文件，并绕过传统的基于文件的防御方法。</li>
</ol>

<h3 id="2-powershell-的混淆技术">2. PowerShell 的混淆技术</h3>

<ol>
  <li><strong>随机化（Randomization）：</strong> 攻击者在不影响脚本执行和语义的情况下对脚本进行随机更改，包括空格随机化、大小写随机、变量和函数名随机化，以及被 PowerShell 忽略的字符，这些技术利用了 PowerShell 解释器对脚本属性不敏感的特点。</li>
  <li><strong>字符串操作（String manipulation）：</strong> 使用包括字符串拆分、字符串反转和字符串重新排序的方法对 PowerShell 中的字符串进行混淆。</li>
  <li><strong>编码（Encoding）：</strong> 编码混淆后的脚本只能反映很少原始脚本的信息。</li>
</ol>

<h3 id="3-混淆技术在-powershell-攻击检测中的有效性">3. 混淆技术在 PowerShell 攻击检测中的有效性</h3>

<p>作者选择了五种具有代表性的混淆方案，并结合不同构造层次的模糊技术和不同的编码方法，前四种混淆方案如下图所示，而对于方案 S5 ，作者采用了基于 AST 的混淆。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-02.png" alt="混淆方案" /></p>

<p>通过对 75 个良性样本和 75 个恶意样本使用上述混淆方式处理后，将原始样本和混淆后的脚本上传至 VirusTotal，实验结果如下图所示，几乎所有混淆方案都可以有效地绕过杀毒软件。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-03.png" alt="VirusTotal 检测结果" /></p>

<h1 id="0x03-总体框架">0x03 总体框架</h1>
<hr />

<p>作者为 PowerShell 设计了一种有效的、轻量级的去混淆机制，并将其作为关键模块，开发了第一个语义感知的 PowerShell 攻击检测系统，攻击检测过程分为如下图三个阶段：</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-04.png" alt="总体框架" /></p>

<ol>
  <li><strong>去混淆阶段（Deobfuscation phase）：</strong> 将 AST 子树视为混淆的最小单元，并在子树上执行恢复，最后构造去混淆后的脚本。这种去混淆功能不仅有利于对 PowerShell 攻击的检测，而且有利于对其分析和取证。</li>
  <li><strong>训练和检测阶段（Training and detection phases）：</strong> 对恶意 PowerShell 脚本数据库采用经典的面向对象关联（Objective-oriented Association，OOA）挖掘算法，实现自动提取 31 条用于签名匹配的 OOA 规则。</li>
  <li><strong>应用场景（Application scenarios）：</strong> 基于去混淆的语义感知攻击检测系统主要是基于静态分析，与动态分析的检测方法相比，具有更高的代码覆盖率和更低的开销；与现有基于静态分析的攻击检测方法相比，更适合处理混淆场景。所以作者提出的系统可以部署到实时攻击检测、大规模恶意软件自动分析等系统。</li>
</ol>

<h1 id="0x04-powershell-去混淆技术">0x04 PowerShell 去混淆技术</h1>
<hr />

<p>作者之所以使用静态方式去混淆主要有以下两点原因：</p>

<ol>
  <li>动态方法需要对现有系统或解释器进行额外的修改或者带来更大的开销</li>
  <li>动态方法有一个已知的限制，即低覆盖率。</li>
</ol>

<p>由于在实际攻击中，脚本中可恢复的部分与其他部分之间没有明确界限，特别是当脚本被多层混淆时。所以作者针对该问题设计了一种基于 AST 子树的方法，首先定位可恢复的片段然后再重新构建原始脚本。具体过程如下图所示，可以分为五个阶段：</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-05.png" alt="去混淆流程" /></p>

<ol>
  <li><strong>可疑子树的提取（Extract Suspicious Subtrees）：</strong> 采用了微软的官方库 System.Management.Automation.Language 将 PowerShell 脚本解析为 AST ，因为只有两种方法可以将恢复的部分直接通过管道（pipes）或间接通过变量传递给上面的顶点。如下图所示，一种为红色块所指的 PipelineAst 节点，另一种为蓝色块所指的 AssignmentStatementAst 节点。并以宽度优先的方式遍历 AST，并将可疑的子树推入堆栈中进行后续步骤。
<img src="https://bu-shuo.github.io/image/2021-08-01-06.png" alt="两种节点" /></li>
  <li><strong>基于子树的混淆检测（Subtree-based Obfuscation Detection）：</strong> 部署二进制分类器通过脚本片段熵、标记（token）的长度、AST 类型的分布和 AST 的深度四种特征去发现混淆的子树或脚本片段（并不是所有满足模糊特征的树都是可恢复的子树），最终选取了 76 种特征并使用基于梯度下降的 Logistics 回归算法进行分类。</li>
  <li><strong>基于仿真的恢复（Emulation-based Recovery）：</strong> 设置一个 PowerShell 执行会话，并执行在上一步中检测到的混淆部分，若为可恢复子树，则返回恢复后的脚本；若为不可恢复子树，则将其标记为非模糊子树，继续下一个模糊子树。</li>
  <li><strong>抽象语法树的更新（AST Update）：</strong> 将恢复的子树或脚本片段解析为新的 AST 并替换更新 AST，循环这样的过程直到没有混淆的子树。</li>
  <li><strong>后处理阶段（Post processing）：</strong> 对混淆过程中引入的语法及更改通过正则表达式进行定位，并进行相应的修改，重新构建脚本片段以获得消除混淆后的脚本。</li>
</ol>

<h1 id="0x05-语义感知的-powershell-攻击检测系统">0x05 语义感知的 PowerShell 攻击检测系统</h1>
<hr />

<p>基于语义感知的系统除了可以提供稳定的攻击检测，还允许对恶意行为进行解释和分类。由于 PowerShell 脚本的 API 包含更高级别的语义，因此 PowerShell 脚本的语义可以更容易地通过命令和函数集来理解，所以该系统采用 API 集来进行语义检测。</p>

<h3 id="1-训练阶段training-phase">1. 训练阶段（Training Phase）</h3>
<p>使用解析器解析得到一组对应于每个去混淆脚本的 AST 节点，然后提取它们的值并对其进行规范化：转换为小写字母，再删除无关字符，最后检查别名。采用基于 OOA 挖掘的经典分类方法对命令项集合进行检测，如下图所示，字母表示命令或函数，用红色标记的集合表示从恶意脚本中提取的项目集，再使用 FP-growth 算法生成频度模式，然后选择满足支持度和置信度大于用户指定的最小值规则的模式。最终，作者为 PowerShell 攻击提取了 31 条确定的 OOA 规则。</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-07.png" alt="提取项目集" /></p>

<h3 id="2-检测阶段detection-phase">2. 检测阶段（Detection Phase）</h3>
<p>使用去混淆的脚本作为项目集，并尝试匹配预先训练的 OOA 规则，结果不仅显示了恶意分数，还显示了脚本的语义。</p>

<h1 id="0x06-实验评估">0x06 实验评估</h1>
<hr />

<h3 id="1-混淆检测的准确性">1. 混淆检测的准确性</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-08.png" alt="混淆检测的准确性" /></p>

<h3 id="2-脚本恢复的质量">2. 脚本恢复的质量</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-09.png" alt="脚本恢复的质量" /></p>

<h3 id="3-去混淆的效率">3. 去混淆的效率</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-10.png" alt="去混淆的效率" /></p>

<h3 id="4-去混淆对-av-检测和语义感知检测结果的影响">4. 去混淆对 AV 检测和语义感知检测结果的影响</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-11.png" alt="去混淆对 AV 检测和语义感知检测结果的影响" /></p>
<h3 id="5-去混淆方法中单个技术的影响">5. 去混淆方法中单个技术的影响</h3>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-12.png" alt="去混淆方法中单个技术的影响" /></p>

<h1 id="0x07-现有工作">0x07 现有工作</h1>
<hr />

<h3 id="1-基于脚本的恶意软件检测">1. 基于脚本的恶意软件检测</h3>
<p>如下图所示，对于脚本的恶意软件检测可以分为三类：</p>

<p><img src="https://bu-shuo.github.io/image/2021-08-01-13.png" alt="恶意软件检测分类" /></p>

<h3 id="2-去混淆方法">2. 去混淆方法</h3>
<p>对于二进制文件的混淆，精确识别混淆是去混淆的第一步，使用基于签名的方法可以在可执行文件种搜索已知的混淆。为了处理未知的混淆方式，最新的研究采用了多特征混淆检测。而对于脚本语言来说，Liu 等人提出了 PSDEM，这是一种主要用于 PowerShell 去混淆的手动方法。Adbelkhalek 提出的 JSDES 是一种混合的方法，用于识别混淆处理的可疑函数，然后对这些函数去混淆。Lu 等人提出的基于语义的方法使用了动态分析和程序切片技术来去混淆，但这种方法的问题是代码覆盖率低。</p>

<h1 id="0x08-总结">0x08 总结</h1>
<hr />

<p>这篇论文作者首先设计了第一种有效且轻量级的去混淆方法，该方法在子树级别上执行混淆检测和基于方针的恢复，在此基础上作者又进一步设计了第一个基于语义感知的 PowerShell 攻击检测系统，该系统包括 31 个 OOA 规则。通过实验，在使用作者设计的去混淆方法后，Windows Defender 和 Virus Total 的攻击检测率从 0.3% 和 2.65% 大幅提高到 75.0% 和 90.0%，而语义感知攻击检测系统的平局准确率为 92.3%，误报率为 0%，要优于 Windows Defender 和 VirusTotal。</p>
:ET