I"<p><br /></p>

<h1 id="0x00-简介">0x00 简介</h1>
<hr />

<p>一个攻击者主要的目标就是完成特定任务并且不被发现，这个过程包括了在目标环境中建立一个立足点并进行横向移动，在真实攻击过程中，攻击者是在对目标安全控制系统所知甚少的情况下进行的。因此，攻击者必须注意调整他们的战略来保证不被安全控制系统所发现。随着新技术的不断发展，安全控制技术也逐渐成熟，这促使各种类型的攻击者调整和改进他们的策略，以此来最大限度提高攻击成功的可能性。</p>

<p>从攻击者的角度来看，最具挑战的新技术就是端点检测响应系统（Endpoint Detection and Response，EDR），它总是被称为未来的杀毒软件（Antivirus，AV）。传统的 AV 主要通过结合签名和启发式分析技术来加强对恶意代码的检测和防御，然而，EDR 主要有两个任务： <strong>对恶意行为和其他签名的检测</strong> 和 <strong>便捷的分析和应急响应</strong> ，因为这些原因，EDR 已经成为全面防御攻击者的要求。</p>

<p>EDR 被设计用来检测发生在端点上的可疑行为，这些行为可能包括一个攻击范围，例如进程执行或进程注入，以及在内存中加载映像。一旦这些行为被识别，EDR 就该发挥第二个作用——作为防御者和应急响应的工具对检测到的行为进行响应。响应的过程包括将受害主机从网络中隔离，快速收集端点日志，重塑事件发生的时间线，收集和记录威胁指标，甚至会终止可以进程。</p>

<p>攻击者则是通过开发新的更复杂的技术去躲避在磁盘和内存上的检测来作为回应。这些技术不局限于传统的初始攻击向量，它们经常利用后渗透技术去躲避检测，实施这些技术的关键是能够 hook 到主机上的所有进程，因为 EDR 技术会在几毫秒内作出许多决定。</p>

<p>如果没有之前的优秀工作，这个项目是不可能实现的。许多人公开了 EDR 和 内存 Hook 方面的创新研究，这些工作的重点是绕过特定的产品。本文的目的则是更深入地探讨该主题，不是专注于仅用于特定产品的技术，而是识别多有 EDR 产品的系统性问题，以及攻击者如何无需事先了解客户的安全栈就可以利用它们绕过 EDR 产品，这需要涉及到先前讨论过的概念。</p>

<h1 id="0x01-什么是-hooking-">0x01 什么是 hooking ？</h1>
<hr />

<p>Hooking 是一项改变程序行为的技术，它允许 EDR 去监控进程的执行流程，收集这些信息用于行为分析和检测可疑或恶意的活动。这使得 EDR 可以更准确地检测初始攻击技术（如代码执行）和后渗透技术（如权限提升、横向移动或勒索软件活动）。</p>

<p>这些 hooks 将数据发送到端点上运行的 EDR 代理，以便实时处理监控的数据。EDR 通常安装在内核级别，需要最高特权访问，这么做的原因主要有两个：第一是避免被攻击者关闭或删除，因为访问内核运行的服务并不容易，想要实施攻击通常需要某种漏洞，或者攻击者已经在端点上取得高级特权。不过由于攻击者通常是“黑盒”攻击，所以假设最初的攻击还没有特权，必须通过后渗透阶段获得，如果不小心执行一些程序，可能就会被 EDR 捕获。第二就是因为在内核中运行可以提供 EDR 访问、控制和监视整个系统。</p>

<p>figure 1</p>

<p>代理经常通过加载他们的 DLL 将 hooks 放入进程中，DLL 会重新映射已经加载过的函数。这使得代理可以监控每个进程，收集监控的数据，通过不断地接受进程、磁盘和网络通信中的变化，代理将数据传递到产品的基于云的平台，在云平台上，所有的数据都将被处理，并且归类为恶意或者良性行为。虽然大部分预防控制是由代理执行，但通过对攻击技术的修改可以绕过代理的初始检测，这就是 EDR 平台在基于大范围收集的数据来识别恶意行为方面真正发挥作用的地方。</p>

<p>figure 2</p>

<p>例如，一个进程产生一个挂起的新进程，并修改新进程的内存权限去执行 WriteProcessMemory 过程，写入的数据是经过加密的，所以不会触发代理的任何恶意指标。然而，发送到 EDR 平台的监控数据仍然可以查看，并且将这些事件识别为 Process Hollowing 技术。所有的过程都在不到一秒的时间发生，为了确保威胁不会成功，这意味着代理需要带两的数据来作出分析决策。</p>

<p>为了进一步了解数据流如何工作，我们需要对 Windows 架构有所了解。首先，Windows 系统提供了大量的函数和 API 调用，应用程序可以利用它们执行代码。Windows API 的主要作用是在调用系统调用执行底层指令前对齐所有堆栈寄存器。</p>

<p>像 NTAllocateVitualMemory 等系统调用提供了一个低级接口，允许进程和操作系统交互。这些接口是过渡到内核的底层汇编指令，用于告诉 CPU 执行诸如分配内存、创建文件或将存储在特定缓冲区的数据写入磁盘等操作。这些系统调用驻留在 ntdll.dll 动态链接库（DLL）中，其中有许多没有记录，因为他们只执行底层汇编指令，系统调用不能被直接调用。</p>

<p>figure 3</p>

<p>当一个进程被执行时，系统 DLL 被加载，此时 EDR 代理 hook 特定的 API 函数和系统调用，如 VirtualAlloc 和 NTAllocateVirtualMemory。需要注意的是，每个 EDR 平台 hook 不同的函数和系统调用，提供不同的监控，进而产生不同的信息和不同的检测结果。随着执行流程的进行，EDR 的 hook 被触发，强制执行从系统 DLL 跳转到 EDR DLL，此时 EDR 执行一系列指令，然后返回系统 DLL。</p>

<p>figure 4</p>

<p>如下图所示，同一个系统调用被调用两次，这是由于用户模式和内核模式之间的转换。系统调用可能以字符 NT 或 ZW 为前缀，NT 系统调用表示来自用户模式的调用， ZW 系统调用表示来自内核模式的系统调用。无论前缀如何，底层的系统调用指令都是相同的。</p>

<p>figure 5</p>

:ET